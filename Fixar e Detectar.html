	<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fixar e Detectar - Terapia Visual</title>
    <style>
        /* --- CSS: Estilização e Layout --- */
        :root {
            --bg-color: #2c3e50;       /* Azul escuro neutro (confortável) */
            --text-color: #ecf0f1;     /* Branco suave */
            --accent-color: #3498db;   /* Azul destaque */
            --success-color: #2ecc71;  /* Verde para acertos */
            --danger-color: #e74c3c;   /* Vermelho para erros */
            --target-color: #e74c3c;   /* Cor do alvo central */
            --stimulus-color: #ffffff; /* Cor do estímulo periférico */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none; /* Impede seleção de texto ao tocar */
            -webkit-user-select: none;
            touch-action: manipulation; /* Melhora resposta ao toque */
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Remove rolagem */
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Telas (Start, Game, Results) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Oculto por padrão */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .active {
            display: flex;
        }

        /* --- Tela Inicial e Configurações --- */
        h1 { margin-bottom: 20px; font-size: 2.5rem; text-align: center; }
        p { font-size: 1.2rem; margin-bottom: 30px; text-align: center; max-width: 80%; }

        .config-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 80%;
            max-width: 600px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        input[type="range"] {
            width: 50%;
            cursor: pointer;
        }

        /* Botões */
        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            background-color: var(--accent-color);
            color: white;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .btn:active { transform: scale(0.95); }
        .btn-restart { background-color: var(--success-color); margin-top: 20px; }

        /* --- Tela do Jogo --- */
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Alvo Central (Fixação) */
        #fixation-target {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            z-index: 5;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Cruz de fixação */
        #fixation-target::before, #fixation-target::after {
            content: '';
            position: absolute;
            background-color: var(--target-color);
        }
        #fixation-target::before { width: 4px; height: 100%; }
        #fixation-target::after { width: 100%; height: 4px; }

        /* Estímulo Periférico */
        #stimulus {
            position: absolute;
            border-radius: 50%;
            background-color: var(--stimulus-color);
            display: none; /* Oculto até ser ativado */
            pointer-events: none; /* O clique é na tela, não no elemento */
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Feedback visual do clique */
        .click-feedback {
            position: absolute;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            width: 0;
            height: 0;
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: ripple 0.4s linear;
        }

        @keyframes ripple {
            to { width: 100px; height: 100px; opacity: 0; }
        }

        /* --- Tela de Resultados --- */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
        }
        .stat-value { font-size: 2.5rem; font-weight: bold; display: block; }
        .stat-label { font-size: 1rem; opacity: 0.8; }
        .color-hit { color: var(--success-color); }
        .color-miss { color: #f39c12; } /* Laranja */
        .color-error { color: var(--danger-color); }

    </style>
</head>
<body>

    <div id="start-screen" class="screen active">
        <h1>Fixar e Detectar</h1>
        <p>Mantenha o olhar no centro. Toque em qualquer lugar da tela assim que perceber um ponto branco aparecer na visão periférica.</p>

        <div class="config-panel">
            <div class="config-item">
                <label>Tempo do Estímulo (ms): <span id="val-time">300</span></label>
                <input type="range" id="cfg-time" min="100" max="1000" step="50" value="300">
            </div>
            <div class="config-item">
                <label>Tamanho do Estímulo (px): <span id="val-size">20</span></label>
                <input type="range" id="cfg-size" min="10" max="50" step="5" value="20">
            </div>
            <div class="config-item">
                <label>Duração da Rodada (s): <span id="val-duration">60</span></label>
                <input type="range" id="cfg-duration" min="30" max="300" step="10" value="60">
            </div>
            <div class="config-item">
                <label>Opacidade (Contraste): <span id="val-opacity">100</span>%</label>
                <input type="range" id="cfg-opacity" min="10" max="100" step="10" value="100">
            </div>
        </div>

        <button class="btn" onclick="game.start()">INICIAR JOGO</button>
    </div>

    <div id="game-screen" class="screen">
        <div id="game-area">
            <div id="fixation-target"></div>
            <div id="stimulus"></div>
        </div>
    </div>

    <div id="result-screen" class="screen">
        <h1>Fim da Rodada</h1>
        
        <div class="stats-grid">
            <div class="stat-box">
                <span class="stat-value color-hit" id="res-hits">0</span>
                <span class="stat-label">Acertos (Detectados)</span>
            </div>
            <div class="stat-box">
                <span class="stat-value color-miss" id="res-missed">0</span>
                <span class="stat-label">Omitidos (Não vistos)</span>
            </div>
            <div class="stat-box" style="grid-column: span 2;">
                <span class="stat-value color-error" id="res-errors">0</span>
                <span class="stat-label">Falsos Positivos (Erros)</span>
            </div>
        </div>

        <button class="btn btn-restart" onclick="game.reset()">NOVA RODADA</button>
    </div>

    <script>
        /**
         * Lógica do Jogo "Fixar e Detectar"
         * Desenvolvido para Terapia Visual
         */
        
        const game = {
            // Estado do jogo
            state: {
                isPlaying: false,
                isStimulusActive: false,
                stimulusTimer: null,
                gameTimer: null,
                nextSpawnTimer: null
            },
            
            // Métricas
            stats: {
                hits: 0,
                missed: 0,
                errors: 0 // Falso positivo (clique sem estímulo)
            },

            // Configuração atual
            config: {
                stimulusTime: 300,
                stimulusSize: 20,
                roundDuration: 60,
                opacity: 1.0
            },

            // Elementos do DOM
            elements: {
                startScreen: document.getElementById('start-screen'),
                gameScreen: document.getElementById('game-screen'),
                resultScreen: document.getElementById('result-screen'),
                stimulus: document.getElementById('stimulus'),
                gameArea: document.getElementById('game-area'),
                // Displays de Configuração
                inputs: {
                    time: document.getElementById('cfg-time'),
                    size: document.getElementById('cfg-size'),
                    duration: document.getElementById('cfg-duration'),
                    opacity: document.getElementById('cfg-opacity')
                },
                displays: {
                    time: document.getElementById('val-time'),
                    size: document.getElementById('val-size'),
                    duration: document.getElementById('val-duration'),
                    opacity: document.getElementById('val-opacity')
                },
                // Displays de Resultado
                resHits: document.getElementById('res-hits'),
                resMissed: document.getElementById('res-missed'),
                resErrors: document.getElementById('res-errors')
            },

            // Inicialização
            init: function() {
                this.setupListeners();
                this.updateConfigDisplay();
            },

            // Configura os ouvintes de eventos
            setupListeners: function() {
                // Atualização em tempo real dos sliders
                const update = () => this.updateConfigDisplay();
                this.elements.inputs.time.addEventListener('input', update);
                this.elements.inputs.size.addEventListener('input', update);
                this.elements.inputs.duration.addEventListener('input', update);
                this.elements.inputs.opacity.addEventListener('input', update);

                // Clique/Toque na área do jogo
                // Usamos 'pointerdown' para cobrir mouse e touch com resposta rápida
                this.elements.gameArea.addEventListener('pointerdown', (e) => this.handleInput(e));
            },

            // Atualiza os números na tela de configuração
            updateConfigDisplay: function() {
                const els = this.elements;
                els.displays.time.textContent = els.inputs.time.value;
                els.displays.size.textContent = els.inputs.size.value;
                els.displays.duration.textContent = els.inputs.duration.value;
                els.displays.opacity.textContent = els.inputs.opacity.value;
                
                // Salva na config interna
                this.config.stimulusTime = parseInt(els.inputs.time.value);
                this.config.stimulusSize = parseInt(els.inputs.size.value);
                this.config.roundDuration = parseInt(els.inputs.duration.value);
                this.config.opacity = parseInt(els.inputs.opacity.value) / 100;
            },

            // Inicia a rodada
            start: function() {
                this.state.isPlaying = true;
                this.stats = { hits: 0, missed: 0, errors: 0 };
                
                // Troca de telas
                this.elements.startScreen.classList.remove('active');
                this.elements.resultScreen.classList.remove('active');
                this.elements.gameScreen.classList.add('active');

                // Aplica estilo configurado ao estímulo
                this.elements.stimulus.style.width = this.config.stimulusSize + 'px';
                this.elements.stimulus.style.height = this.config.stimulusSize + 'px';
                this.elements.stimulus.style.opacity = this.config.opacity;

                // Timer global da rodada
                this.state.gameTimer = setTimeout(() => {
                    this.end();
                }, this.config.roundDuration * 1000);

                // Agenda o primeiro estímulo
                this.scheduleNextStimulus();
            },

            // Agenda o próximo estímulo em um tempo aleatório
            scheduleNextStimulus: function() {
                if (!this.state.isPlaying) return;

                // Intervalo aleatório entre 1s e 3s para evitar previsibilidade
                const delay = Math.random() * 2000 + 1000;
                
                this.state.nextSpawnTimer = setTimeout(() => {
                    this.showStimulus();
                }, delay);
            },

            // Exibe o estímulo na tela
            showStimulus: function() {
                if (!this.state.isPlaying) return;

                const stimulus = this.elements.stimulus;
                
                // Lógica de Posicionamento para evitar o centro
                // Usa coordenadas polares para distribuir ao redor do centro
                const angle = Math.random() * Math.PI * 2;
                
                // Raio mínimo (evita sobrepor fixação) e máximo (mantém na tela)
                // Usando vmin (menor dimensão da tela) para garantir visibilidade
                const minRadius = 15; // % de vmin
                const maxRadius = 45; // % de vmin
                const radiusPercent = minRadius + Math.random() * (maxRadius - minRadius);
                
                // Cálculo da posição. Centro é 50%, 50%
                // Ajustamos para vh/vw para garantir que não saia em telas wide
                const w = window.innerWidth;
                const h = window.innerHeight;
                const minDim = Math.min(w, h);
                const rPixels = (minDim * radiusPercent) / 100;

                const x = (w / 2) + rPixels * Math.cos(angle);
                const y = (h / 2) + rPixels * Math.sin(angle);

                stimulus.style.left = x + 'px';
                stimulus.style.top = y + 'px';
                stimulus.style.display = 'block';
                
                this.state.isStimulusActive = true;

                // Timer para esconder o estímulo (Omissão se não clicar)
                this.state.stimulusTimer = setTimeout(() => {
                    this.handleMiss();
                }, this.config.stimulusTime);
            },

            // Jogador não respondeu a tempo
            handleMiss: function() {
                if (!this.state.isPlaying) return;
                
                this.hideStimulus();
                this.stats.missed++;
                this.scheduleNextStimulus();
            },

            // Esconde o estímulo
            hideStimulus: function() {
                this.elements.stimulus.style.display = 'none';
                this.state.isStimulusActive = false;
                if (this.state.stimulusTimer) clearTimeout(this.state.stimulusTimer);
            },

            // Processa o clique/toque do jogador
            handleInput: function(e) {
                if (!this.state.isPlaying) return;

                // Feedback visual do toque (ripple)
                this.createRipple(e.clientX, e.clientY);

                if (this.state.isStimulusActive) {
                    // ACERTO
                    this.stats.hits++;
                    this.hideStimulus(); // some imediatamente ao acertar
                    this.scheduleNextStimulus();
                } else {
                    // ERRO (Falso Positivo)
                    // Ignora cliques rápidos demais logo após um acerto para evitar contagem dupla acidental
                    this.stats.errors++;
                }
            },

            // Efeito visual de clique
            createRipple: function(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'click-feedback';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                this.elements.gameArea.appendChild(ripple);
                setTimeout(() => ripple.remove(), 400);
            },

            // Fim de jogo
            end: function() {
                this.state.isPlaying = false;
                clearTimeout(this.state.gameTimer);
                clearTimeout(this.state.stimulusTimer);
                clearTimeout(this.state.nextSpawnTimer);
                this.hideStimulus();

                // Mostra resultados
                this.elements.gameScreen.classList.remove('active');
                this.elements.resultScreen.classList.add('active');

                this.elements.resHits.textContent = this.stats.hits;
                this.elements.resMissed.textContent = this.stats.missed;
                this.elements.resErrors.textContent = this.stats.errors;
            },

            // Voltar ao menu inicial
            reset: function() {
                this.elements.resultScreen.classList.remove('active');
                this.elements.startScreen.classList.add('active');
            }
        };

        // Inicia o script
        game.init();

    </script>
</body>
</html>
